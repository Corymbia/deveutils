#!/bin/bash
CMD=$0
PRINTSUB=$(dirname $(readlink -f ${CMD}))/gis-print-sub
REPO_DIR=$(git rev-parse --show-toplevel)
GIT="git -c color.ui="
if [ -t 1 ]; then 
  GIT="${GIT}always"
else
  GIT="${GIT}auto"
fi
GIT_CHANGED=" status -s --untracked=no"
GIT_UNCOMMITTED=" status -s --untracked=all | egrep -v '^\?\?'"
if [ -e ${REPO_DIR}/../.gitmodules ]; then
  REPO_DIR=$(readlink -f ${REPO_DIR}/../)

fi
SUBWIDTH=$(cd ${REPO_DIR}; git submodule | awk '{if(max<length($2)) max=length($2)}END{print max+2}')
COLS=$(tput cols)
WIDTH=$(echo "${COLS}-${SUBWIDTH}" | bc)
RED="\E[1;31m"
RESET="\E[0m"
WHITE="\E[1;37m"
GREEN="\E[0;32m"
ERRMSG=1

UNSAFECOMMANDS="commit rebase merge show notes"
function unsafeCommand() {
  for c in ${UNSAFECOMMANDS}; do
    if echo "${@}" | grep $c; then
      return 0
    fi
  done
  return 1
}

function checkBranches() {
  if (cd ${REPO_DIR}; 
      git status -sb  --untracked=no --ignore-submodules=all;
      git submodule foreach git status -sb  --untracked=no --ignore-submodules=all
     ) | 
     egrep '^\#\#' | sort | uniq -c | wc -l | egrep '^[^1]$' >/dev/null; then
    tput bold
    echo -n "==== "
    tput setaf 1
    echo -n "MUST FIX: Mismatched branches present!"
    tput setaf 7
    echo " ===="
    tput sgr0
    (cd ${REPO_DIR}; 
      for mod in $(git submodule | awk '{print $2}'); do
        ( cd $mod;
          printRedir $mod ${GIT} status -sb --untracked=no --ignore-submodules=untracked
        )
      done
      mod=internal
      printRedir $mod ${GIT} status -sb --untracked=no --ignore-submodules=untracked
    )
    ERRMSG=$((ERRMSG*4))
    return 4
  else
    return 0
  fi 
}

function checkModules() {
  if (cd ${REPO_DIR}; git status -s --untracked=no --ignore-submodules=untracked ) | grep '.' >/dev/null; then
    tput bold
    echo -n "==== "
    tput setaf 1
    echo -n "MUST FIX: Uncommitted submodules present!"
    tput setaf 7
    echo " ===="
    tput sgr0
    (cd ${REPO_DIR}; 
      for mod in $(git submodule | awk '{print $2}'); do
        printRedir $mod ${GIT} status -s --untracked=no --ignore-submodules=untracked $mod
        printRedir $mod ${GIT} diff --ignore-submodules=untracked $mod
      done
    )
    ERRMSG=$((ERRMSG*4))
    return 4
  else
    return 0
  fi 
}

function checkUncommitted() {
  if submodulesExec status -s --untracked=no --ignore-submodules=all | grep '.' >/dev/null; then
    tput bold
    echo -n "==== "
    tput setaf 1
    echo -n "MUST FIX: Uncommitted changes present!"
    tput setaf 7
    echo " ===="
    tput sgr0
    submodulesExec status -s --untracked=no --ignore-submodules=all 
    ERRMSG=$((ERRMSG*4))
    return 2
  fi
}

function stripAnsi() {
  echo -en "${@}" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
}

function printSub() {
  COLOR=${GREEN}
  if [[ "$1" == "ERROR" ]]; then
    shift
    COLOR=${RED}
  fi
  SUFFIX=$1
  shift
  while IFS= read -r line; do
    line=$(echo -en "$line")
    cline=$(stripAnsi "${line}")
    len=${#line}
    clen=${#cline}
    sublen=${#SUFFIX}
    len=$((len%COLS))
    clen=$((clen%COLS))
    subpad=$((SUBWIDTH-1))
    pad=$((COLS-clen-SUBWIDTH))
#    line=${line//\n/}
    fulllen=$((clen+pad+subpad))
    OUT=$(printf "%-${len}s" "${line}")
    if [ ${subpad} -gt 0 ] && [ ${pad} -gt 0 ] && [ $fulllen -lt $COLS ]; then
      OUT=${OUT}$(printf "%-${pad}.${pad}s" " ")
      OUT=${OUT}$(printf "${COLOR}#${WHITE}")
      OUT=${OUT}$(printf "%${subpad}.${subpad}s${RESET}" " $SUFFIX")
    fi
    tput sgr0
    printf -- "${OUT}\n"
#    printf "$len $clen $pad $subpad $sublen $fulllen\n"
  done
}

function printSuberr() {
  MODULE=$1
  shift
  printSub ERROR $MODULE "${@}"
}

function printRedir() {
  MODULE=$1
  shift
  {
    {
      ${@} 3>&- |
      printSub  ${MODULE} {} 2>&3 3>&-
    } 2>&1 >&4 4>&- |
    printSuberr ${MODULE} {} 3>&- 4>&-
  } 3>&2 4>&1
}

function topExec() {
  ( cd ${REPO_DIR}
    if ! unsafeCommand ${@}; then
      printRedir $(basename ${REPO_DIR}) ${GIT} "${@}"
    else
      ${GIT} "${@}"
    fi
  )
}

function submodulesExec() {
  ( cd ${REPO_DIR}
    for m in $(git submodule | awk '{print $2}'); do
      ( cd $m
        if ! unsafeCommand ${@}; then
          printRedir $m ${GIT} "${@}"
        else
          ${GIT} "${@}"
        fi
      )
    done
    if ! unsafeCommand ${@}; then
      printRedir $(basename ${REPO_DIR}) ${GIT} ${@}
    else
      ${GIT} ${@}
    fi
  )
}

if complete | egrep ' gis$'; then
  (
  echo "Bash completion command to give git command completion:"
  echo
  echo "  complete -o bashdefault -o default -o nospace -F _git gis"
  echo
  echo "- Either add this to your ~/.bashrc"
  echo "- Stuff it into a file in /etc/bash_completion.d/gis" 
  ) >&2
  exit 1
fi

if [[ "$(basename $CMD)" == "gist" ]]; then
  topExec "${@}"
elif [[ "$(basename $CMD)" == "gisd" ]]; then
  submodulesExec ${@}
elif declare -F $1 >/dev/null; then
  C=$1
  shift
  $C ${@}
else
  checkModules >&2
  checkBranches >&2
  checkUncommitted >&2
  if [ ${ERRMSG} -gt 1 ]; then
    exit $ERRMSG
  fi
  submodulesExec ${@}
fi
